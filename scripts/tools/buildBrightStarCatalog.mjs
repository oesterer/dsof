#!/usr/bin/env node

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { BAYER_GREEK, CONSTELLATION_GENITIVE } from '../../data/starNames.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..', '..');

const BSC_FILE = path.join(projectRoot, 'data', 'catalog');
const HYG_FILE = path.join(projectRoot, 'data', 'hyg_v36.csv');
const OUTPUT_FILE = path.join(projectRoot, 'data', 'brightStars.js');

const DISPLAY_NAME_OVERRIDES = new Map([
  [7528, 'Delta Cygni'],
]);

const hygCatalog = fs.existsSync(HYG_FILE) ? loadHygCatalog(HYG_FILE) : new Map();

let stars;
if (fs.existsSync(BSC_FILE)) {
  stars = parseBrightStarCatalog(BSC_FILE, hygCatalog);
} else if (hygCatalog.size) {
  stars = Array.from(hygCatalog.values()).map((entry) => ({
    hr: entry.hr,
    name: entry.proper || formatBayerName(entry.bayer, entry.component, entry.constellation) ||
      formatFlamsteedName(entry.flam, entry.constellation) || `HR ${entry.hr}`,
    raHours: entry.raHours,
    decDeg: entry.decDeg,
    mag: entry.vmag,
    properName: entry.proper || undefined,
    bayer: entry.bayer || undefined,
    flamsteed: entry.flam || undefined,
    constellation: entry.constellation || undefined,
  }));
} else {
  console.error('No input data found. Download data/catalog (BSC) or data/hyg_v36.csv first.');
  process.exit(1);
}

stars.sort((a, b) => a.hr - b.hr);

const fileHeader = `// Auto-generated by scripts/tools/buildBrightStarCatalog.mjs\n`;
const fileBody = `export const BRIGHT_STARS = ${JSON.stringify(stars, null, 2)};\n`;
fs.writeFileSync(OUTPUT_FILE, fileHeader + fileBody, 'utf8');

console.log(`Wrote ${stars.length} entries to ${path.relative(projectRoot, OUTPUT_FILE)}`);

function parseBrightStarCatalog(filePath, hygCatalog) {
  const lines = fs.readFileSync(filePath, 'utf8').split(/\r?\n/).filter(Boolean);
  const stars = [];
  for (const line of lines) {
    const hrString = line.slice(0, 4).trim();
    if (!hrString) {
      continue;
    }
    const hr = Number.parseInt(hrString, 10);
    if (!Number.isFinite(hr)) {
      continue;
    }

    const hygEntry = hygCatalog.get(hr);
    const baseName = line.slice(4, 14).trim();

    const raHours = parseRightAscension(line.slice(75, 77), line.slice(77, 79), line.slice(79, 83));
    const decDeg = parseDeclination(line.slice(83, 84), line.slice(84, 86), line.slice(86, 88), line.slice(88, 90));
    const vmag = safeParseFloat(line.slice(102, 107));

    const derivedDesignation = parseBaseDesignation(baseName);
    const hygBayerInfo = splitBayerCode(hygEntry?.bayer);

    let bayer = derivedDesignation.bayer || hygBayerInfo.bayer;
    let component = derivedDesignation.component || hygBayerInfo.component;
    const flam = derivedDesignation.flam || hygienicValue(hygEntry?.flam);
    const constellation = derivedDesignation.constellation || hygienicValue(hygEntry?.constellation);
    const proper = hygienicValue(hygEntry?.proper);

    const overrideName = DISPLAY_NAME_OVERRIDES.get(hr);
    const displayName = overrideName || proper ||
      formatBayerName(bayer, component, constellation) ||
      formatFlamsteedName(flam, constellation) ||
      derivedDesignation.dm ||
      (baseName ? baseName.replace(/\s+/g, ' ') : '') ||
      `HR ${hr}`;

    const star = {
      hr,
      name: displayName,
      raHours: roundMaybe(raHours, 6),
      decDeg: roundMaybe(decDeg, 6),
      mag: roundMaybe(vmag, 3),
    };

    if (proper && proper !== displayName) {
      star.properName = proper;
    }
    if (bayer) {
      star.bayer = bayer;
    }
    if (component) {
      star.component = component;
    }
    if (flam) {
      star.flamsteed = flam;
    }
    if (constellation) {
      star.constellation = constellation;
    }
    if (derivedDesignation.dm) {
      star.dm = derivedDesignation.dm;
    }

    stars.push(star);
  }
  return stars;
}

function loadHygCatalog(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  const lines = content.trim().split(/\r?\n/);
  const header = lines.shift();
  if (!header) {
    return new Map();
  }
  const columns = header.split(',');
  const indexes = {
    id: columns.indexOf('id'),
    hr: columns.indexOf('hr'),
    ra: columns.indexOf('ra'),
    dec: columns.indexOf('dec'),
    mag: columns.indexOf('mag'),
    proper: columns.indexOf('proper'),
    bayer: columns.indexOf('bayer'),
    flam: columns.indexOf('flam'),
    constellation: columns.indexOf('con'),
  };

  const catalog = new Map();
  for (const rawLine of lines) {
    if (!rawLine) continue;
    const line = rawLine.replace(/\r$/, '');
    const parts = line.split(',');
    if (parts.length > columns.length) {
      parts.length = columns.length;
    } else if (parts.length < columns.length) {
      while (parts.length < columns.length) {
        parts.push('');
      }
    }

    const hrValue = parts[indexes.hr]?.trim();
    if (!hrValue) {
      continue;
    }
    const hr = Number.parseInt(hrValue, 10);
    if (!Number.isFinite(hr)) {
      continue;
    }

    const ra = safeParseFloat(parts[indexes.ra]);
    const dec = safeParseFloat(parts[indexes.dec]);
    const mag = safeParseFloat(parts[indexes.mag]);

    catalog.set(hr, {
      hr,
      proper: hygienicValue(parts[indexes.proper]),
      bayer: hygienicValue(parts[indexes.bayer]),
      flam: hygienicValue(parts[indexes.flam]),
      constellation: hygienicValue(parts[indexes.constellation]),
      raHours: roundMaybe(ra, 6),
      decDeg: roundMaybe(dec, 6),
      vmag: roundMaybe(mag, 3),
    });
  }

  return catalog;
}

function parseRightAscension(hoursRaw, minutesRaw, secondsRaw) {
  const hours = safeParseInt(hoursRaw);
  const minutes = safeParseInt(minutesRaw);
  const seconds = safeParseFloat(secondsRaw);
  if (!Number.isFinite(hours) || !Number.isFinite(minutes) || !Number.isFinite(seconds)) {
    return null;
  }
  return hours + minutes / 60 + seconds / 3600;
}

function parseDeclination(signRaw, degreesRaw, minutesRaw, secondsRaw) {
  const sign = (signRaw || '').trim() === '-' ? -1 : 1;
  const degrees = safeParseInt(degreesRaw);
  const minutes = safeParseInt(minutesRaw);
  const seconds = safeParseInt(secondsRaw);
  if (!Number.isFinite(degrees) || !Number.isFinite(minutes) || !Number.isFinite(seconds)) {
    return null;
  }
  const absolute = degrees + minutes / 60 + seconds / 3600;
  return sign * absolute;
}

function formatBayerName(bayer, component, constellation) {
  if (!bayer) {
    return '';
  }
  const match = bayer.match(/^([A-Za-z]{3})(.*)$/);
  const base = match ? match[1] : bayer;
  const suffix = (match ? match[2] : '').trim();
  const greek = BAYER_GREEK[capitalize(base.slice(0, 3))] || capitalize(base);
  const componentSuffix = suffix ? ` ${suffix}` : component ? ` ${component}` : '';
  const constellationName = constellation ? (CONSTELLATION_GENITIVE[constellation] || constellation) : '';
  if (!constellationName) {
    return `${greek}${componentSuffix}`.trim();
  }
  return `${greek}${componentSuffix} ${constellationName}`.trim();
}

function formatFlamsteedName(flam, constellation) {
  if (!flam) {
    return '';
  }
  const constellationName = constellation ? (CONSTELLATION_GENITIVE[constellation] || constellation) : '';
  if (!constellationName) {
    return flam;
  }
  return `${flam} ${constellationName}`;
}

function parseBaseDesignation(raw) {
  const cleaned = (raw || '').trim();
  if (!cleaned) {
    return {};
  }
  if (/^(BD|CD|CPD|IDS|LTT|AG|GJ|LP)/i.test(cleaned)) {
    return { dm: cleaned };
  }

  const parts = cleaned.split(/\s+/);
  let constellation = '';
  if (parts.length > 0) {
    const maybeConst = parts[parts.length - 1];
    if (maybeConst && Object.prototype.hasOwnProperty.call(CONSTELLATION_GENITIVE, maybeConst)) {
      constellation = parts.pop();
    }
  }

  const combined = parts.join('');
  if (!combined) {
    return { constellation };
  }

  let flam = '';
  let bayer = '';
  let component = '';

  const mainMatch = combined.match(/^(\d*)([A-Za-z]{3})([0-9A-Za-z]*)$/);
  if (mainMatch) {
    flam = mainMatch[1] || '';
    bayer = mainMatch[2] || '';
    component = mainMatch[3] || '';
  } else {
    const altMatch = combined.match(/^(\d*)([A-Za-z]+)$/);
    if (altMatch) {
      flam = altMatch[1] || '';
      bayer = altMatch[2] || '';
    } else if (/^\d+$/.test(combined)) {
      flam = combined;
    } else {
      bayer = combined;
    }
  }

  if (!constellation && component && component.length >= 3) {
    const maybeConst = component.slice(-3);
    if (Object.prototype.hasOwnProperty.call(CONSTELLATION_GENITIVE, maybeConst)) {
      constellation = maybeConst;
      component = component.slice(0, -3);
    }
  }

  if (bayer && bayer.includes('-')) {
    const [base, comp] = bayer.split('-', 2);
    if (base) {
      bayer = base;
    }
    if (!component && comp) {
      component = comp;
    }
  }

  return {
    bayer: bayer || '',
    component: component || '',
    flam: flam || '',
    constellation: constellation || '',
  };
}

function safeParseFloat(value) {
  const trimmed = (value || '').trim();
  if (!trimmed) {
    return null;
  }
  const number = Number.parseFloat(trimmed);
  return Number.isFinite(number) ? number : null;
}

function safeParseInt(value) {
  const trimmed = (value || '').trim();
  if (!trimmed) {
    return null;
  }
  const number = Number.parseInt(trimmed, 10);
  return Number.isFinite(number) ? number : null;
}

function roundMaybe(value, decimals) {
  if (!Number.isFinite(value)) {
    return null;
  }
  const factor = 10 ** decimals;
  return Math.round(value * factor) / factor;
}

function capitalize(value) {
  if (!value) return value;
  return value[0].toUpperCase() + value.slice(1).toLowerCase();
}

function hygienicValue(value) {
  const trimmed = (value || '').trim();
  return trimmed || '';
}

function splitBayerCode(raw) {
  const value = hygienicValue(raw);
  if (!value) {
    return { bayer: '', component: '' };
  }
  const normalized = value.replace(/−/g, '-');
  const [symbolPart, suffixPart = ''] = normalized.split('-', 2);
  let bayer = symbolPart;
  let component = suffixPart;

  const match = symbolPart.match(/^([A-Za-z]{3})([0-9A-Za-z]*)$/);
  if (match) {
    bayer = match[1] || '';
    if (match[2]) {
      component = match[2] + component;
    }
  }

  return {
    bayer: bayer || '',
    component: component || '',
  };
}
